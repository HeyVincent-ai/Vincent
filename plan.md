# SafeSkills - Product Plan

## Overview

SafeSkills is a secure secret management service designed specifically for AI agents. Instead of giving agents direct access to secrets (like private keys or API credentials), SafeSkills stores secrets on behalf of users and executes actions using those secrets when requested by authorized agents. The agent never sees the actual secret value.

## Problem Statement

AI agents increasingly need to perform sensitive operations that require secrets (wallet keys, API keys, credentials). Current approaches either:
1. Give agents direct access to secrets (risky - agents could leak or misuse them)
2. Require complex manual approval flows for every action (slow, poor UX)

SafeSkills provides a middle ground: agents can request actions that use secrets, but policies control what actions are allowed, and humans can approve when needed.

## Core Concepts

### Secrets
- Secrets are stored in PostgreSQL (encrypted at rest by the database)
- Each secret has a **type** (e.g., `evm_wallet`, future: `api_key`, `ssh_key`, etc.)
- Each secret has a **memo/description** field for user notes
- Secrets are "claimable" - created via API, user claims ownership later

**How secrets get into the database:**
1. **Generated by SafeSkills** (current focus): For skills like `evm_wallet`, we generate the secret (private key) ourselves. The agent never sees it.
2. **Set by user** (future): For some secret types, user claims an "empty" secret placeholder and enters the secret value via the frontend.

For the wallet skill, we use approach #1 - we generate the EOA private key server-side.

### Skills
- A skill is a capability tied to a secret type
- Skills define what actions can be performed with that secret type
- First skill: **EVM Wallet** (Ethereum/blockchain transactions)

### Policies
- Policies govern how secrets can be used
- Different secret types have different policy options
- Policies can require human approval for certain actions

### API Keys
- Each secret can have multiple API keys for agent access
- API keys can be created, listed, and revoked
- API keys are scoped to a specific secret

## Architecture

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   AI Agent      │────▶│  SafeSkills API │────▶│   PostgreSQL    │
│                 │     │   (Backend)     │     │   (Secrets DB)  │
└─────────────────┘     └────────┬────────┘     └─────────────────┘
                                 │
                                 ▼
                        ┌─────────────────┐
                        │  Skill Executor │
                        │  (e.g. ZeroDev) │
                        └─────────────────┘
                                 │
        ┌────────────────────────┼────────────────────────┐
        ▼                        ▼                        ▼
┌───────────────┐     ┌─────────────────┐     ┌─────────────────┐
│ Telegram Bot  │     │  Frontend App   │     │  Blockchain     │
│ (Approvals)   │     │  (User Portal)  │     │  (EVM Chains)   │
└───────────────┘     └─────────────────┘     └─────────────────┘
```

## User Flows

### Flow 1: Zero-Config Agent Onboarding (Wallet)
1. Agent calls API to create a new wallet
2. API generates EOA private key, creates ZeroDev smart account, returns:
   - API key for the agent
   - Claim URL for the owner
   - Smart account address
3. Agent immediately starts using the wallet via API
4. Owner can later claim via URL, add policies, and configure approvals

### Flow 1b: User-Provided Secret (Future)
1. Agent calls API to create a secret placeholder (for non-generated secret types)
2. API returns:
   - API key for the agent
   - Claim URL for the owner
3. Owner opens claim URL, authenticates, and enters the secret value
4. Agent can now use the secret via API

### Flow 2: User Claims and Configures Secret
1. User opens claim URL
2. User authenticates via Stytch (email/OAuth)
3. Secret is associated with user's account
4. User can:
   - View secret metadata (not the secret itself)
   - Set policies (allowlists, spending limits, etc.)
   - Configure Telegram for approvals
   - Manage API keys (create, revoke)

### Flow 3: Agent Executes Action
1. Agent calls API with API key and action request
2. Backend validates API key
3. Backend checks policies:
   - If allowed by policy → execute immediately
   - If requires approval → send Telegram notification
   - If denied by policy → return error
4. If approved, execute action using stored secret
5. Return result to agent

## First Skill: EVM Wallet

### Secret Type: `evm_wallet`

When a wallet is created:
1. We generate an EOA (externally owned account) private key server-side
2. We create a ZeroDev smart account owned by that EOA
3. The private key is stored in our DB (PostgreSQL encrypted at rest)
4. The smart account address is returned to the agent
5. The agent never sees the private key

### Capabilities

#### 1. Transfer
- Send ETH or ERC20 tokens
- Parameters: `to`, `amount`, `token` (address or "ETH")
- Policies:
  - **Spending limits**: Max amount per tx, per day, per week (in USD)
  - **To address allowlist**: Only send to approved addresses
  - **Token allowlist**: Only transfer approved tokens

#### 2. Send Transaction
- Execute arbitrary contract calls
- Parameters: `to`, `data`, `value`
- Policies:
  - **To address allowlist**: Only interact with approved contracts
  - **Function selector allowlist**: Only call approved functions
  - **Value limits**: Max ETH value per tx (in USD)

### Policy Types for EVM Wallet

| Policy | Description | Applies To |
|--------|-------------|------------|
| `address_allowlist` | List of allowed recipient/contract addresses | transfer, sendTx |
| `function_allowlist` | List of allowed function selectors (4-byte) | sendTx |
| `spending_limit_per_tx` | Max USD value per transaction | transfer, sendTx |
| `spending_limit_daily` | Max USD value per 24 hours | transfer, sendTx |
| `spending_limit_weekly` | Max USD value per 7 days | transfer, sendTx |
| `token_allowlist` | List of allowed ERC20 tokens | transfer |
| `require_approval` | Always require human approval | transfer, sendTx |
| `approval_threshold` | Require approval above USD amount | transfer, sendTx |

### Gas Abstraction

We handle gas for users via ZeroDev's paymaster:

- **Testnets**: Gas is sponsored for free (we pay)
- **Mainnets**: Requires paid subscription ($10/month)

**How it works:**
1. All transactions go through ZeroDev smart accounts
2. ZeroDev's paymaster sponsors the gas
3. We pay ZeroDev for the gas used
4. We track gas costs per-user in our database
5. Monthly billing passes through mainnet gas costs to users

**Gas tracking:**
- Each transaction records the gas cost in USD
- Costs are aggregated per user per month
- Users can view their gas usage in the dashboard

### Human Approval (Telegram)

1. User configures Telegram username in frontend
2. User starts conversation with SafeSkills bot
3. When approval needed:
   - Bot sends message with action details
   - User replies "approve" or "deny"
   - Action executes or fails accordingly
4. Timeout: If no response in X minutes, action is denied

## Tech Stack

| Component | Technology |
|-----------|------------|
| Backend API | Node.js + TypeScript + Express |
| Database | PostgreSQL |
| ORM | Prisma |
| Authentication | Stytch |
| Smart Accounts | ZeroDev |
| Payments | Stripe |
| Approval Bot | Telegram Bot API |
| Hosting | Heroku |
| Frontend | React + TypeScript |

## Database Schema (Conceptual)

### Users
- id, email, stytch_user_id, telegram_username, telegram_chat_id, stripe_customer_id, created_at

### Secrets
- id, user_id (nullable until claimed), type, value (nullable for future user-set secrets), memo, claim_token, claimed_at, created_at

### WalletSecretMetadata
- id, secret_id, smart_account_address, chain_id

### ApiKeys
- id, secret_id, key_hash, name, created_at, revoked_at

### Policies
- id, secret_id, policy_type, policy_config (JSON), created_at

### TransactionLog
- id, secret_id, api_key_id, action_type, request_data, response_data, status, approved_by, created_at

### PendingApprovals
- id, transaction_log_id, expires_at, approved, responded_at

### AuditLog
- id, secret_id, api_key_id (nullable), user_id (nullable), action, input_data (JSON), output_data (JSON), status, error_message, ip_address, user_agent, created_at

### Subscriptions
- id, user_id, stripe_customer_id, stripe_subscription_id, status (active, canceled, past_due), current_period_start, current_period_end, created_at

### GasUsage
- id, secret_id, user_id, transaction_hash, chain_id, gas_used, gas_price_gwei, cost_usd, created_at

### MonthlyGasSummary
- id, user_id, month (YYYY-MM), total_cost_usd, billed, stripe_invoice_id, created_at

## Audit Logging

All skill executions and admin actions are logged with full input/output data for transparency:

**What gets logged:**
- All skill executions (transfer, sendTransaction, etc.)
- Policy checks and their results
- Approval requests and responses
- API key creation/revocation
- Policy changes
- Secret claims

**Log entry contains:**
- Timestamp
- Action type
- Full request input (sanitized if needed)
- Full response output
- Success/failure status
- Error details if failed
- Which API key or user triggered it
- IP address and user agent

**Admin access:**
- Admins (users who have claimed the secret) can view full audit logs via frontend
- Logs are filterable by date, action type, status
- Export capability for compliance

## Billing Model

### Pricing
- **Free tier**: Testnets only, unlimited usage
- **Pro tier**: $10/month subscription + mainnet gas costs

### Subscription Flow
1. User attempts to use mainnet without subscription
2. API returns error with link to subscribe
3. User enters credit card via Stripe Checkout
4. Subscription activates, mainnet access enabled

### Gas Billing
1. Each mainnet transaction records gas cost in USD
2. At end of month, aggregate gas costs per user
3. Create Stripe invoice for gas usage
4. Charge user's card on file
5. Send receipt via email

### Billing Rules
- Subscription is per-user, covers all their wallets
- Gas costs are passed through at cost (no markup for MVP)
- Failed transactions that use gas are still billed
- Users can view usage and invoices in dashboard

## API Endpoints

### Secret Management
- `POST /api/secrets` - Create secret (we generate it, returns API key + claim URL)
- `GET /api/secrets/:id` - Get secret metadata (requires auth)
- `POST /api/secrets/:id/claim` - Claim a secret (requires auth + claim token)
- `PUT /api/secrets/:id/value` - Set secret value (for future user-provided secrets, requires auth + unclaimed)

### API Key Management
- `POST /api/secrets/:id/api-keys` - Create new API key
- `GET /api/secrets/:id/api-keys` - List API keys
- `DELETE /api/secrets/:id/api-keys/:keyId` - Revoke API key

### Policy Management
- `GET /api/secrets/:id/policies` - List policies
- `POST /api/secrets/:id/policies` - Create/update policy
- `DELETE /api/secrets/:id/policies/:policyId` - Remove policy

### Skill Execution (Agent API)
- `POST /api/skills/evm-wallet/transfer` - Execute transfer
- `POST /api/skills/evm-wallet/send-transaction` - Execute arbitrary tx
- `GET /api/skills/evm-wallet/balance` - Check balances
- `GET /api/skills/evm-wallet/address` - Get smart account address

### Audit Logs
- `GET /api/secrets/:id/audit-logs` - List audit logs for a secret (admin only)
- `GET /api/secrets/:id/audit-logs/:logId` - Get single audit log detail
- `GET /api/secrets/:id/audit-logs/export` - Export logs as CSV/JSON

### Billing
- `GET /api/billing/subscription` - Get current subscription status
- `POST /api/billing/subscribe` - Create Stripe checkout session
- `POST /api/billing/webhook` - Stripe webhook handler
- `GET /api/billing/usage` - Get current month gas usage
- `GET /api/billing/invoices` - List past invoices
- `POST /api/billing/cancel` - Cancel subscription

### User Management
- `POST /api/auth/stytch-callback` - Stytch auth callback
- `GET /api/user/profile` - Get user profile
- `PUT /api/user/telegram` - Set Telegram username

## Security Considerations

1. **Database Encryption**: PostgreSQL encrypted at rest (Heroku provides this)
2. **API Key Hashing**: API keys hashed with bcrypt, only shown once on creation
3. **Rate Limiting**: Aggressive rate limiting on all endpoints
4. **Comprehensive Audit Logging**: All actions logged with full inputs/outputs, viewable by admin
5. **Claim Token Security**: Claim tokens are one-time use, expire after 7 days
6. **Telegram Verification**: User must initiate conversation with bot to enable approvals
7. **Secret Isolation**: Agents never see raw secret values, only use them via skill actions

## Future Considerations

- Additional secret types (API keys, SSH keys, OAuth tokens)
- More approval channels (email, SMS, app push)
- Team/organization support
- Programmable policies (custom logic)
- Self-hosted option
- Multiple chain support for EVM wallet
- Session keys for reduced approval friction

---

## Implementation Progress & Learnings

### Phase 1: Project Setup & Infrastructure (COMPLETED)

**Completed: 2026-01-31**

**What was implemented:**
- Node.js/TypeScript project with strict tsconfig
- ESLint + Prettier for code quality
- Full folder structure as planned
- Environment variable management with Zod validation
- Docker + docker-compose for local development with PostgreSQL
- Prisma ORM with comprehensive schema (all models from the plan)
- Express server with TypeScript
- Middleware stack: cors, helmet, rate-limiting, request logging
- Error handling with custom AppError class and async wrapper
- Health check endpoint at `/health`
- Standard API response format with success/error helpers

**Key decisions made:**
- Using `tsx` for development (faster than ts-node)
- Environment validation happens at startup (fail fast)
- All Prisma model names use snake_case in database (via @@map)
- Comprehensive audit logging schema includes duration tracking
- TransactionLog separate from AuditLog for cleaner separation of concerns

**Files created:**
- `src/index.ts` - Server entry point with graceful shutdown
- `src/app.ts` - Express app configuration
- `src/db/client.ts` - Prisma client singleton
- `src/utils/env.ts` - Environment validation
- `src/utils/response.ts` - API response helpers
- `src/types/index.ts` - TypeScript types
- `src/api/middleware/errorHandler.ts` - Error handling
- `src/api/middleware/requestLogger.ts` - Request logging
- `prisma/schema.prisma` - Full database schema
- `prisma/seed.ts` - Database seeding
- `docker-compose.yml` - Local development environment
- `Dockerfile` and `Dockerfile.dev` - Container builds

**Next up: Phase 2 - Secret Storage Foundation**
- Implement secret creation service (with wallet generation)
- API key generation and validation
- Secret claiming flow

### Phase 2: Secret Storage Foundation (COMPLETED)

**Completed: 2026-01-31**

**What was implemented:**
- Secret service with full CRUD: create, retrieve, claim, set value, soft delete
- EVM_WALLET secret creation generates EOA private key + placeholder smart account address
- Non-wallet secret types create placeholder with null value awaiting user input
- Claim token generation (64-char hex) with configurable expiry (default 7 days)
- Claim tokens are one-time use and invalidated after claiming
- API key service: generation, bcrypt hashing, validation, listing, revocation
- API key format: `ssk_<64 hex chars>` prefix for easy identification
- API key auth middleware (Bearer token in Authorization header)
- Optional API key auth middleware for dual-purpose endpoints
- Secret access validation middleware (ensures API key matches requested secret)
- Full REST API routes for secrets and API keys
- Zod validation on all request bodies
- Secret creation endpoint returns API key + claim URL in single response

**Key decisions made:**
- Express 5 returns `string | string[]` for params/query - used `str()` helper to safely extract strings
- API key validation iterates all non-revoked keys and bcrypt-compares (noted: will need optimization at scale, e.g. key fingerprinting)
- User auth (Phase 3) is stubbed: userId passed via request body/query params for testing
- Wallet address generation is placeholder - will be replaced by ZeroDev in Phase 5
- `toPublicData()` pattern ensures secret values never leak to API responses

**Files created:**
- `src/services/secret.service.ts` - Secret CRUD business logic
- `src/services/apiKey.service.ts` - API key management business logic
- `src/services/index.ts` - Service exports
- `src/api/middleware/apiKeyAuth.ts` - API key authentication middleware
- `src/api/routes/secrets.routes.ts` - Secret API endpoints
- `src/api/routes/apiKeys.routes.ts` - API key management endpoints
- `src/api/routes/index.ts` - Route aggregation

**Files modified:**
- `src/app.ts` - Mounted API router

**Known issues:**
- ESLint config needs migration to ESLint 9 flat config format (`eslint.config.js`)
- Initial Prisma migration not yet run (requires Docker daemon)
- API key validation is O(n) over all keys - needs optimization for production scale

**Next up: Phase 3 - Authentication & User Management**
- Stytch integration for user auth
- Session management
- Replace userId stubs with real auth
