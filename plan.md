# SafeSkills - Product Plan

## Overview

SafeSkills is a secure secret management service designed specifically for AI agents. Instead of giving agents direct access to secrets (like private keys or API credentials), SafeSkills stores secrets on behalf of users and executes actions using those secrets when requested by authorized agents. The agent never sees the actual secret value.

## Problem Statement

AI agents increasingly need to perform sensitive operations that require secrets (wallet keys, API keys, credentials). Current approaches either:
1. Give agents direct access to secrets (risky - agents could leak or misuse them)
2. Require complex manual approval flows for every action (slow, poor UX)

SafeSkills provides a middle ground: agents can request actions that use secrets, but policies control what actions are allowed, and humans can approve when needed.

## Core Concepts

### Secrets
- Secrets are stored in PostgreSQL (encrypted at rest by the database)
- Each secret has a **type** (e.g., `evm_wallet`, future: `api_key`, `ssh_key`, etc.)
- Each secret has a **memo/description** field for user notes
- Secrets are "claimable" - created via API, user claims ownership later

**How secrets get into the database:**
1. **Generated by SafeSkills** (current focus): For skills like `evm_wallet`, we generate the secret (private key) ourselves. The agent never sees it.
2. **Set by user** (future): For some secret types, user claims an "empty" secret placeholder and enters the secret value via the frontend.

For the wallet skill, we use approach #1 - we generate the EOA private key server-side.

### Skills
- A skill is a capability tied to a secret type
- Skills define what actions can be performed with that secret type
- First skill: **EVM Wallet** (Ethereum/blockchain transactions)

### Policies
- Policies govern how secrets can be used
- Different secret types have different policy options
- Policies can require human approval for certain actions

### API Keys
- Each secret can have multiple API keys for agent access
- API keys can be created, listed, and revoked
- API keys are scoped to a specific secret

## Architecture

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   AI Agent      │────▶│  SafeSkills API │────▶│   PostgreSQL    │
│                 │     │   (Backend)     │     │   (Secrets DB)  │
└─────────────────┘     └────────┬────────┘     └─────────────────┘
                                 │
                                 ▼
                        ┌─────────────────┐
                        │  Skill Executor │
                        │  (e.g. ZeroDev) │
                        └─────────────────┘
                                 │
        ┌────────────────────────┼────────────────────────┐
        ▼                        ▼                        ▼
┌───────────────┐     ┌─────────────────┐     ┌─────────────────┐
│ Telegram Bot  │     │  Frontend App   │     │  Blockchain     │
│ (Approvals)   │     │  (User Portal)  │     │  (EVM Chains)   │
└───────────────┘     └─────────────────┘     └─────────────────┘
```

## User Flows

### Flow 1: Zero-Config Agent Onboarding (Wallet)
1. Agent calls API to create a new wallet
2. API generates EOA private key, creates ZeroDev smart account, returns:
   - API key for the agent
   - Claim URL for the owner
   - Smart account address
3. Agent immediately starts using the wallet via API
4. Owner can later claim via URL, add policies, and configure approvals

### Flow 1b: User-Provided Secret (Future)
1. Agent calls API to create a secret placeholder (for non-generated secret types)
2. API returns:
   - API key for the agent
   - Claim URL for the owner
3. Owner opens claim URL, authenticates, and enters the secret value
4. Agent can now use the secret via API

### Flow 2: User Claims and Configures Secret
1. User opens claim URL
2. User authenticates via Stytch (email/OAuth)
3. Secret is associated with user's account
4. User can:
   - View secret metadata (not the secret itself)
   - Set policies (allowlists, spending limits, etc.)
   - Configure Telegram for approvals
   - Manage API keys (create, revoke)

### Flow 3: Agent Executes Action
1. Agent calls API with API key and action request
2. Backend validates API key
3. Backend checks policies:
   - If allowed by policy → execute immediately
   - If requires approval → send Telegram notification
   - If denied by policy → return error
4. If approved, execute action using stored secret
5. Return result to agent

## First Skill: EVM Wallet

### Secret Type: `evm_wallet`

When a wallet is created:
1. We generate an EOA (externally owned account) private key server-side
2. We create a ZeroDev smart account owned by that EOA
3. The private key is stored in our DB (PostgreSQL encrypted at rest)
4. The smart account address is returned to the agent
5. The agent never sees the private key

### Capabilities

#### 1. Transfer
- Send ETH or ERC20 tokens
- Parameters: `to`, `amount`, `token` (address or "ETH")
- Policies:
  - **Spending limits**: Max amount per tx, per day, per week (in USD)
  - **To address allowlist**: Only send to approved addresses
  - **Token allowlist**: Only transfer approved tokens

#### 2. Send Transaction
- Execute arbitrary contract calls
- Parameters: `to`, `data`, `value`
- Policies:
  - **To address allowlist**: Only interact with approved contracts
  - **Function selector allowlist**: Only call approved functions
  - **Value limits**: Max ETH value per tx (in USD)

### Policy Types for EVM Wallet

| Policy | Description | Applies To |
|--------|-------------|------------|
| `address_allowlist` | List of allowed recipient/contract addresses | transfer, sendTx |
| `function_allowlist` | List of allowed function selectors (4-byte) | sendTx |
| `spending_limit_per_tx` | Max USD value per transaction | transfer, sendTx |
| `spending_limit_daily` | Max USD value per 24 hours | transfer, sendTx |
| `spending_limit_weekly` | Max USD value per 7 days | transfer, sendTx |
| `token_allowlist` | List of allowed ERC20 tokens | transfer |
| `require_approval` | Always require human approval | transfer, sendTx |
| `approval_threshold` | Require approval above USD amount | transfer, sendTx |

### Gas Abstraction

We handle gas for users via ZeroDev's paymaster:

- **Testnets**: Gas is sponsored for free (we pay)
- **Mainnets**: Requires paid subscription ($10/month)

**How it works:**
1. All transactions go through ZeroDev smart accounts
2. ZeroDev's paymaster sponsors the gas
3. We pay ZeroDev for the gas used
4. We track gas costs per-user in our database
5. Monthly billing passes through mainnet gas costs to users

**Gas tracking:**
- Each transaction records the gas cost in USD
- Costs are aggregated per user per month
- Users can view their gas usage in the dashboard

### Human Approval (Telegram)

1. User configures Telegram username in frontend
2. User starts conversation with SafeSkills bot
3. When approval needed:
   - Bot sends message with action details
   - User replies "approve" or "deny"
   - Action executes or fails accordingly
4. Timeout: If no response in X minutes, action is denied

## Tech Stack

| Component | Technology |
|-----------|------------|
| Backend API | Node.js + TypeScript + Express |
| Database | PostgreSQL |
| ORM | Prisma |
| Authentication | Stytch |
| Smart Accounts | ZeroDev |
| Payments | Stripe |
| Approval Bot | Telegram Bot API |
| Hosting | Railway |
| Frontend | React + TypeScript |

## Database Schema (Conceptual)

### Users
- id, email, stytch_user_id, telegram_username, telegram_chat_id, stripe_customer_id, created_at

### Secrets
- id, user_id (nullable until claimed), type, value (nullable for future user-set secrets), memo, claim_token, claimed_at, created_at

### WalletSecretMetadata
- id, secret_id, smart_account_address, chain_id

### ApiKeys
- id, secret_id, key_hash, name, created_at, revoked_at

### Policies
- id, secret_id, policy_type, policy_config (JSON), created_at

### TransactionLog
- id, secret_id, api_key_id, action_type, request_data, response_data, status, approved_by, created_at

### PendingApprovals
- id, transaction_log_id, expires_at, approved, responded_at

### AuditLog
- id, secret_id, api_key_id (nullable), user_id (nullable), action, input_data (JSON), output_data (JSON), status, error_message, ip_address, user_agent, created_at

### Subscriptions
- id, user_id, stripe_customer_id, stripe_subscription_id, status (active, canceled, past_due), current_period_start, current_period_end, created_at

### GasUsage
- id, secret_id, user_id, transaction_hash, chain_id, gas_used, gas_price_gwei, cost_usd, created_at

### MonthlyGasSummary
- id, user_id, month (YYYY-MM), total_cost_usd, billed, stripe_invoice_id, created_at

## Audit Logging

All skill executions and admin actions are logged with full input/output data for transparency:

**What gets logged:**
- All skill executions (transfer, sendTransaction, etc.)
- Policy checks and their results
- Approval requests and responses
- API key creation/revocation
- Policy changes
- Secret claims

**Log entry contains:**
- Timestamp
- Action type
- Full request input (sanitized if needed)
- Full response output
- Success/failure status
- Error details if failed
- Which API key or user triggered it
- IP address and user agent

**Admin access:**
- Admins (users who have claimed the secret) can view full audit logs via frontend
- Logs are filterable by date, action type, status
- Export capability for compliance

## Billing Model

### Pricing
- **Free tier**: Testnets only, unlimited usage
- **Pro tier**: $10/month subscription + mainnet gas costs

### Subscription Flow
1. User attempts to use mainnet without subscription
2. API returns error with link to subscribe
3. User enters credit card via Stripe Checkout
4. Subscription activates, mainnet access enabled

### Gas Billing
1. Each mainnet transaction records gas cost in USD
2. At end of month, aggregate gas costs per user
3. Create Stripe invoice for gas usage
4. Charge user's card on file
5. Send receipt via email

### Billing Rules
- Subscription is per-user, covers all their wallets
- Gas costs are passed through at cost (no markup for MVP)
- Failed transactions that use gas are still billed
- Users can view usage and invoices in dashboard

## API Endpoints

### Secret Management
- `POST /api/secrets` - Create secret (we generate it, returns API key + claim URL)
- `GET /api/secrets/:id` - Get secret metadata (requires auth)
- `POST /api/secrets/:id/claim` - Claim a secret (requires auth + claim token)
- `PUT /api/secrets/:id/value` - Set secret value (for future user-provided secrets, requires auth + unclaimed)

### API Key Management
- `POST /api/secrets/:id/api-keys` - Create new API key
- `GET /api/secrets/:id/api-keys` - List API keys
- `DELETE /api/secrets/:id/api-keys/:keyId` - Revoke API key

### Policy Management
- `GET /api/secrets/:id/policies` - List policies
- `POST /api/secrets/:id/policies` - Create/update policy
- `DELETE /api/secrets/:id/policies/:policyId` - Remove policy

### Skill Execution (Agent API)
- `POST /api/skills/evm-wallet/transfer` - Execute transfer
- `POST /api/skills/evm-wallet/send-transaction` - Execute arbitrary tx
- `GET /api/skills/evm-wallet/balance` - Check balances
- `GET /api/skills/evm-wallet/address` - Get smart account address

### Audit Logs
- `GET /api/secrets/:id/audit-logs` - List audit logs for a secret (admin only)
- `GET /api/secrets/:id/audit-logs/:logId` - Get single audit log detail
- `GET /api/secrets/:id/audit-logs/export` - Export logs as CSV/JSON

### Billing
- `GET /api/billing/subscription` - Get current subscription status
- `POST /api/billing/subscribe` - Create Stripe checkout session
- `POST /api/billing/webhook` - Stripe webhook handler
- `GET /api/billing/usage` - Get current month gas usage
- `GET /api/billing/invoices` - List past invoices
- `POST /api/billing/cancel` - Cancel subscription

### User Management
- `POST /api/auth/stytch-callback` - Stytch auth callback
- `GET /api/user/profile` - Get user profile
- `PUT /api/user/telegram` - Set Telegram username

## Security Considerations

1. **Database Encryption**: PostgreSQL encrypted at rest (Railway provides this)
2. **API Key Hashing**: API keys hashed with bcrypt, only shown once on creation
3. **Rate Limiting**: Aggressive rate limiting on all endpoints
4. **Comprehensive Audit Logging**: All actions logged with full inputs/outputs, viewable by admin
5. **Claim Token Security**: Claim tokens are one-time use, expire after 7 days
6. **Telegram Verification**: User must initiate conversation with bot to enable approvals
7. **Secret Isolation**: Agents never see raw secret values, only use them via skill actions

## Future Considerations

- Additional secret types (API keys, SSH keys, OAuth tokens)
- More approval channels (email, SMS, app push)
- Team/organization support
- Programmable policies (custom logic)
- Self-hosted option
- Multiple chain support for EVM wallet
- Session keys for reduced approval friction

---

## Implementation Progress & Learnings

### Phase 1: Project Setup & Infrastructure (COMPLETED)

**Completed: 2026-01-31**

**What was implemented:**
- Node.js/TypeScript project with strict tsconfig
- ESLint + Prettier for code quality
- Full folder structure as planned
- Environment variable management with Zod validation
- Prisma ORM with comprehensive schema (all models from the plan)
- Express server with TypeScript
- Middleware stack: cors, helmet, rate-limiting, request logging
- Error handling with custom AppError class and async wrapper
- Health check endpoint at `/health`
- Standard API response format with success/error helpers

**Key decisions made:**
- Using `tsx` for development (faster than ts-node)
- Environment validation happens at startup (fail fast)
- All Prisma model names use snake_case in database (via @@map)
- Comprehensive audit logging schema includes duration tracking
- TransactionLog separate from AuditLog for cleaner separation of concerns

**Files created:**
- `src/index.ts` - Server entry point with graceful shutdown
- `src/app.ts` - Express app configuration
- `src/db/client.ts` - Prisma client singleton
- `src/utils/env.ts` - Environment validation
- `src/utils/response.ts` - API response helpers
- `src/types/index.ts` - TypeScript types
- `src/api/middleware/errorHandler.ts` - Error handling
- `src/api/middleware/requestLogger.ts` - Request logging
- `prisma/schema.prisma` - Full database schema
- `prisma/seed.ts` - Database seeding

**Next up: Phase 2 - Secret Storage Foundation**
- Implement secret creation service (with wallet generation)
- API key generation and validation
- Secret claiming flow

### Phase 2: Secret Storage Foundation (COMPLETED)

**Completed: 2026-01-31**

**What was implemented:**
- Secret service with full CRUD: create, retrieve, claim, set value, soft delete
- EVM_WALLET secret creation generates EOA private key + placeholder smart account address
- Non-wallet secret types create placeholder with null value awaiting user input
- Claim token generation (64-char hex) with configurable expiry (default 7 days)
- Claim tokens are one-time use and invalidated after claiming
- API key service: generation, bcrypt hashing, validation, listing, revocation
- API key format: `ssk_<64 hex chars>` prefix for easy identification
- API key auth middleware (Bearer token in Authorization header)
- Optional API key auth middleware for dual-purpose endpoints
- Secret access validation middleware (ensures API key matches requested secret)
- Full REST API routes for secrets and API keys
- Zod validation on all request bodies
- Secret creation endpoint returns API key + claim URL in single response

**Key decisions made:**
- Express 5 returns `string | string[]` for params/query - used `str()` helper to safely extract strings
- API key validation iterates all non-revoked keys and bcrypt-compares (noted: will need optimization at scale, e.g. key fingerprinting)
- User auth (Phase 3) is stubbed: userId passed via request body/query params for testing
- Wallet address generation is placeholder - will be replaced by ZeroDev in Phase 5
- `toPublicData()` pattern ensures secret values never leak to API responses

**Files created:**
- `src/services/secret.service.ts` - Secret CRUD business logic
- `src/services/apiKey.service.ts` - API key management business logic
- `src/services/index.ts` - Service exports
- `src/api/middleware/apiKeyAuth.ts` - API key authentication middleware
- `src/api/routes/secrets.routes.ts` - Secret API endpoints
- `src/api/routes/apiKeys.routes.ts` - API key management endpoints
- `src/api/routes/index.ts` - Route aggregation

**Files modified:**
- `src/app.ts` - Mounted API router

**Known issues:**
- ESLint config needs migration to ESLint 9 flat config format (`eslint.config.js`)
- Initial Prisma migration not yet run (requires local PostgreSQL or DATABASE_URL)
- API key validation is O(n) over all keys - needs optimization for production scale

**Next up: Phase 3 - Authentication & User Management**
- Stytch integration for user auth
- Session management
- Replace userId stubs with real auth

### Phase 3: Authentication & User Management (COMPLETED)

**Completed: 2026-01-31**

**What was implemented:**
- Stytch SDK integration with lazy initialization (only connects when auth is actually used)
- Magic link authentication flow (send link + authenticate token)
- OAuth authentication flow (Google etc. via Stytch)
- Session validation via Stytch sessions API (7-day session duration)
- Session revocation (logout)
- Find-or-create user pattern: matches by stytchUserId first, then email, then creates new
- Session auth middleware with token extraction from Authorization header or x-session-token header
- Optional session auth middleware for dual-purpose endpoints
- Secret ownership validation middleware (requireSecretOwnership)
- User API routes: GET /api/user/profile, PUT /api/user/telegram, GET /api/user/secrets
- Auth API routes: POST /api/auth/magic-link, POST /api/auth/authenticate, POST /api/auth/oauth, POST /api/auth/logout
- Replaced all userId stubs in secrets.routes.ts with real session auth
- GET/PUT/DELETE on secrets now require session + ownership
- POST /api/secrets/:id/claim requires session (userId from req.user)
- POST /api/secrets (create) remains unauthenticated (agent endpoint)

**Key decisions made:**
- Session tokens distinguished from API keys by checking for `ssk_` prefix
- Stytch client initialized lazily to avoid startup failures when credentials aren't configured
- Telegram chat ID is reset when username changes (forces re-linking)
- Secret ownership middleware is separate from session middleware for composability
- Used `req.params as Record<string, string>` pattern instead of the `str()` helper for cleaner Express 5 param access

**Files created:**
- `src/services/auth.service.ts` - Stytch integration and user management
- `src/api/middleware/sessionAuth.ts` - Session auth + ownership middleware
- `src/api/routes/auth.routes.ts` - Authentication endpoints
- `src/api/routes/user.routes.ts` - User profile/settings endpoints

**Files modified:**
- `src/api/routes/secrets.routes.ts` - Replaced userId stubs with real session auth
- `src/api/routes/index.ts` - Mounted auth and user routes
- `src/services/index.ts` - Added auth service export

**Next up: Phase 4 - Policy System**
- Design policy configuration schema
- Implement policy engine core
- EVM wallet-specific policy checkers
- USD price conversion integration

### Phase 4: Policy System (COMPLETED)

**Completed: 2026-01-31**

**What was implemented:**
- Policy service with full CRUD: create, list, get, update, delete
- Zod-based policy config validation per policy type (8 types)
- Policy checker engine with two-phase evaluation: deny conditions first, then approval requirements
- Address allowlist checker: validates `to` address against allowed list
- Function allowlist checker: validates 4-byte function selectors for send_transaction actions
- Token allowlist checker: validates ERC20 token addresses for transfer actions
- Spending limit per-tx checker: compares USD value against max
- Spending limit daily/weekly checkers: rolling window aggregation from TransactionLog
- Require approval checker: forces human approval when enabled
- Approval threshold checker: requires approval above USD threshold
- CoinGecko price service with 5-minute cache, ETH and ERC20 → USD conversion
- Well-known token address → CoinGecko ID mapping for common tokens
- Graceful handling of missing prices (deny for spending limits, require_approval for thresholds)
- Policy REST API with session auth + ownership middleware
- Duplicate policy type prevention (409 Conflict)

**Key decisions made:**
- Default-open policy: if no policies exist, actions are allowed
- Allowlist policies are restrictive: if present, action MUST match or it's denied
- When USD price is unavailable, spending limits deny (safe default) and approval thresholds require approval (safe default)
- Daily/weekly spending tracked via `usdValue` field in TransactionLog.requestData (set at execution time by skill executor)
- Policy routes mounted at `/api/secrets/:secretId/policies` with `mergeParams: true`
- One policy per type per secret (enforced in service layer, not DB constraint)

**Files created:**
- `src/services/policy.service.ts` - Policy CRUD + config validation schemas
- `src/services/price.service.ts` - CoinGecko price fetching with caching
- `src/policies/checker.ts` - Policy evaluation engine with all 8 checkers
- `src/policies/index.ts` - Policy module exports
- `src/api/routes/policies.routes.ts` - Policy REST API endpoints

**Files modified:**
- `src/api/routes/index.ts` - Mounted policy routes
- `src/services/index.ts` - Added policy and price service exports

**Next up: Phase 5 - EVM Wallet Skill**
- ZeroDev integration for smart accounts
- Gas tracking
- Transfer and send transaction functions
- Skill API endpoints

### Phase 5: EVM Wallet Skill (COMPLETED)

**Completed: 2026-01-31**

**What was implemented:**
- ZeroDev SDK v5.5.7 integration with Kernel v3.1 smart accounts and EntryPoint v0.7
- Smart account creation from EOA private key via ZeroDev
- Secret creation now creates real ZeroDev smart accounts when ZERODEV_PROJECT_ID is configured (falls back to placeholder otherwise)
- Default chain changed from mainnet (1) to Sepolia testnet (11155111) for safety
- ZeroDev paymaster integration for gas sponsorship on all transactions
- Multi-chain support architecture (mainnet + Sepolia, extensible via CHAIN_MAP)
- Gas tracking service: records gas usage per transaction with USD conversion via CoinGecko
- Gas usage queries by secret and by user with date filtering
- Subscription check before mainnet transactions (testnets always free)
- ETH transfer via ZeroDev smart account with policy checks
- ERC20 transfer with automatic decimal fetching and token amount conversion
- Generic send transaction for arbitrary contract calls
- Full policy integration: deny/allow/require_approval flow with TransactionLog recording
- Pending approval creation for require_approval verdicts (Telegram integration deferred to Phase 6)
- Balance checking: ETH and ERC20 (with symbol and decimals)
- Smart account address retrieval
- REST API endpoints with Zod validation:
  - `POST /api/skills/evm-wallet/transfer`
  - `POST /api/skills/evm-wallet/send-transaction`
  - `GET /api/skills/evm-wallet/balance` (supports `?tokens=addr1,addr2`)
  - `GET /api/skills/evm-wallet/address`
- All skill endpoints authenticated via API key middleware

**Key decisions made:**
- ZeroDev SDK v5 uses viem's native account abstraction (no more `permissionless` package needed)
- Constants like `KERNEL_V3_1` and `getEntryPoint` are accessed via `constants` namespace export from `@zerodev/sdk`
- Paymaster is passed directly as `paymaster: paymasterClient` to `createKernelAccountClient` (v5 API)
- Gas recording is available but not auto-triggered on every tx (can be called by caller when receipt is available)
- USD value is stored in TransactionLog.requestData for spending limit window calculations
- Transfer amounts are accepted as human-readable strings (e.g. "0.1" ETH) and converted to wei internally
- Policy check happens before execution; on deny/require_approval, no on-chain tx is sent

**Files created:**
- `src/skills/zerodev.service.ts` - ZeroDev smart account creation, transaction execution, balance queries
- `src/skills/evmWallet.service.ts` - High-level EVM wallet skill: transfer, sendTx, balance, address with policy integration
- `src/skills/gas.service.ts` - Gas usage recording, queries, subscription checks
- `src/skills/index.ts` - Skill module exports
- `src/api/routes/evmWallet.routes.ts` - REST API endpoints for EVM wallet skill

**Files modified:**
- `src/services/secret.service.ts` - Uses real ZeroDev smart account creation when configured, default chain → Sepolia
- `src/api/routes/index.ts` - Mounted EVM wallet skill routes at `/skills/evm-wallet`
- `package.json` - Added `@zerodev/sdk`, `@zerodev/ecdsa-validator`, `viem` dependencies

**Next up: Phase 6 - Human Approval System**
- Telegram bot setup
- User linking flow
- Approval request/response via inline keyboards
- Timeout handling

### Phase 6: Human Approval System (COMPLETED)

**Completed: 2026-01-31**

**What was implemented:**
- Grammy (Telegram bot SDK) integration with long polling mode
- Bot startup/shutdown integrated into server lifecycle (index.ts)
- User linking flow: API endpoint generates 10-minute linking codes, user sends `/start <code>` to bot
- `/start`, `/status`, `/unlink` commands for Telegram bot
- Inline keyboard approval flow: Approve/Deny buttons on formatted transaction details
- Callback query handler validates user ownership, expiry, and duplicate responses
- On approval: transaction is immediately executed via `approvalExecutor.ts` (re-reads wallet data, executes via ZeroDev)
- On denial: transaction log updated to DENIED status
- Periodic timeout checker (every 60 seconds) expires pending approvals past their deadline
- Expired approvals marked as DENIED with TIMEOUT status on TransactionLog
- Timeout notifications sent to user via Telegram
- `sendApprovalRequest()` called fire-and-forget from evmWallet.service when policy requires approval
- `sendNotification()` utility for arbitrary messages to linked users
- Telegram message ID stored on PendingApproval for reference

**Key decisions made:**
- Used grammy over node-telegram-bot-api (better TypeScript support, active maintenance)
- Long polling instead of webhooks (simpler for development; can switch to webhooks for production)
- Linking codes stored in-memory with 10-minute expiry (sufficient for single-instance; would need Redis for multi-instance)
- Approval execution is separate module (`approvalExecutor.ts`) to avoid circular dependencies with evmWallet.service
- Fire-and-forget pattern for sending approval requests (non-blocking for agent API response)
- Timeout checker runs as setInterval (simple; could upgrade to a proper job queue for production)

**Files created:**
- `src/telegram/bot.ts` - Bot initialization, commands, callback handling, approval messaging
- `src/telegram/approvalExecutor.ts` - Executes approved transactions after Telegram approval
- `src/telegram/timeoutChecker.ts` - Periodic job to expire timed-out approvals
- `src/telegram/index.ts` - Module exports

**Files modified:**
- `src/index.ts` - Bot startup/shutdown in server lifecycle
- `src/skills/evmWallet.service.ts` - Calls sendApprovalRequest after creating PendingApproval
- `src/api/routes/user.routes.ts` - Added POST /api/user/telegram/link endpoint
- `package.json` - Added `grammy` dependency

**Next up: Phase 7 - Secret Management API (for Agents)**
- Agent info endpoint
- Response formatting standardization

### Phase 7: Secret Management API for Agents (COMPLETED)

**Completed: 2026-01-31**

**What was implemented:**
- All Phase 7 functionality was already built during earlier phases (2 and 5)
- `POST /api/secrets` creates secret, returns API key + claim URL + wallet address (Phase 2)
- `GET /api/secrets/info` returns secret metadata via API key auth (Phase 2)
- `toPublicData()` pattern ensures agent never receives raw secret values
- Standardized response format via `sendSuccess`/`sendError` helpers (Phase 1)
- Transaction hashes included in transfer/sendTransaction responses (Phase 5)
- Approval status (`executed`, `pending_approval`, `denied`) in all skill responses (Phase 5)
- Clear error messages via `AppError` class with error codes (Phase 1)

**Key observations:**
- Phase 7 was essentially a verification phase - the incremental build approach in earlier phases already covered all requirements
- Response shape for `POST /api/secrets` returns `{ secret: { id, type, memo, walletAddress, chainId, ... }, apiKey: { id, key }, claimUrl }`
- Response shape for skill endpoints returns `{ txHash, status, smartAccountAddress, reason?, transactionLogId }`
- No code changes were needed

**Next up: Phase 8 - Billing & Subscriptions**
- Stripe SDK integration
- Subscription management (checkout, webhooks, cancellation)
- Gas usage billing (monthly aggregation, invoicing)

### Phase 8: Billing & Subscriptions (COMPLETED)

**Completed: 2026-01-31**

**What was implemented:**
- Stripe SDK v20 (stripe@20.3.0) integration with lazy initialization
- Stripe customer creation (get-or-create pattern, stored on User model)
- Checkout session creation for $10/month subscription via Stripe Checkout
- Subscription cancellation at period end via Stripe API
- Stripe webhook handler for 5 event types:
  - `checkout.session.completed` - activates subscription with period dates
  - `invoice.paid` - confirms subscription active
  - `invoice.payment_failed` - marks subscription as PAST_DUE
  - `customer.subscription.deleted` - marks subscription as CANCELED
  - `customer.subscription.updated` - syncs status and period dates
- Raw body capture in Express for Stripe webhook signature verification
- Monthly gas aggregation service:
  - Per-user per-month gas cost summation from GasUsage records
  - MonthlyGasSummary upsert (creates or updates)
  - Batch aggregation across all users for a given month
  - Current month usage with recent transaction details
  - Historical usage summaries
- Billing REST API endpoints (all session-authenticated):
  - `GET /api/billing/subscription` - subscription status
  - `POST /api/billing/subscribe` - create Stripe Checkout session
  - `POST /api/billing/cancel` - cancel subscription
  - `POST /api/billing/webhook` - Stripe webhook (signature-authenticated)
  - `GET /api/billing/usage` - current month gas usage
  - `GET /api/billing/usage/history` - monthly usage history
  - `GET /api/billing/invoices` - past billed invoices
- Duplicate subscription prevention (409 if already subscribed)

**Key decisions made:**
- Stripe SDK v20 (API version 2026-01-28.clover) has breaking changes from older versions:
  - `current_period_start/end` moved from `Subscription` to `SubscriptionItem` - implemented `extractPeriodDates()` helper that reads from first item
  - `Invoice.subscription` field removed - replaced by `invoice.parent.subscription_details.subscription` path
  - `apiVersion` parameter no longer needed in constructor (SDK defaults to its bundled version)
- Raw body for webhook verification captured via `express.json({ verify })` callback that stores buffer on `req.rawBody`
- Gas invoice creation via Stripe metered billing deferred - requires more Stripe product configuration and is better done when the billing flow is tested end-to-end
- Gas aggregation is callable on-demand (not cron-based yet) - production deployment can trigger via cron or scheduled task

**Files created:**
- `src/billing/stripe.service.ts` - Stripe customer, checkout, subscription, and webhook handling
- `src/billing/gasAggregation.service.ts` - Monthly gas cost aggregation and usage queries
- `src/billing/index.ts` - Module exports
- `src/api/routes/billing.routes.ts` - Billing REST API endpoints

**Files modified:**
- `src/app.ts` - Added raw body capture for webhook signature verification
- `src/api/routes/index.ts` - Mounted billing routes at `/billing`
- `package.json` - Added `stripe` dependency

**Deferred items:**
- Stripe metered billing for gas usage invoicing (requires Stripe product setup)
- Marking MonthlyGasSummary as billed after invoice payment
- Cron job for end-of-month gas aggregation

### Phase 9: Frontend Application (COMPLETED)

**Completed: 2026-01-31**

**What was implemented:**
- React + TypeScript + Vite project in `frontend/` directory
- Tailwind CSS v4 via `@tailwindcss/vite` plugin
- React Router v7 with protected routes and public-only routes
- Axios-based API client with session token management and 401 auto-redirect
- Auth context provider with session persistence in localStorage
- Login page with magic link email flow
- Auth callback page that exchanges Stytch tokens for sessions
- Dashboard listing all claimed secrets with type badges and wallet addresses
- Secret detail page with metadata display, delete functionality
- Tabbed interface for policies and API keys on secret detail
- Policy manager: list, create (all 8 types with dynamic config forms), delete
- API key manager: list, create (with one-time key display + clipboard copy), revoke
- Settings page with Telegram username configuration and linking code generation
- Claim page: requires auth, claims secret via token, redirects to dashboard
- Billing page: subscription status, Stripe Checkout redirect, cancel flow, current month usage, usage history, invoices
- Vite dev server proxies `/api` to backend on port 3000
- Production build verified (Vite build succeeds, TypeScript clean)

**Key decisions made:**
- Tailwind CSS v4 uses `@import "tailwindcss"` instead of v3's `@tailwind` directives
- `@tailwindcss/vite` plugin handles Tailwind processing (no PostCSS config needed)
- Auth state stored in React context + localStorage for persistence across refreshes
- API client auto-removes session and redirects to `/login` on 401 responses
- Claim page is accessible without layout (no nav bar) since user may not be logged in yet
- OAuth login button deferred (Stytch OAuth requires additional frontend SDK setup)
- Policy edit UI deferred (create + delete covers core needs; edit can be done via delete+recreate)
- Audit log and gas usage summary on secret detail page deferred to Phase 10

**Files created:**
- `frontend/` - Full Vite + React + TypeScript project
- `frontend/src/api.ts` - Axios API client with all endpoint functions
- `frontend/src/auth.tsx` - Auth context provider and `useAuth` hook
- `frontend/src/components/Layout.tsx` - App shell with nav bar
- `frontend/src/components/PolicyManager.tsx` - Policy CRUD component
- `frontend/src/components/ApiKeyManager.tsx` - API key CRUD component
- `frontend/src/pages/Login.tsx` - Magic link login
- `frontend/src/pages/AuthCallback.tsx` - Auth token exchange
- `frontend/src/pages/Dashboard.tsx` - Secret list
- `frontend/src/pages/SecretDetail.tsx` - Secret detail with tabs
- `frontend/src/pages/Settings.tsx` - Telegram configuration
- `frontend/src/pages/Claim.tsx` - Secret claim flow
- `frontend/src/pages/Billing.tsx` - Subscription and usage

**Post-Phase 9 Update: Stytch UI SDK Migration**
- Replaced custom magic link login flow with Stytch pre-built UI SDK (`@stytch/react`)
- Installed `@stytch/react` and `@stytch/vanilla-js` in frontend
- Wrapped app with `StytchProvider` using `StytchUIClient` in `main.tsx`
- Login page now renders `<StytchLogin>` component with email magic links + Google OAuth
- AuthCallback uses `useStytchSession` hook to detect Stytch session, then syncs to backend
- New backend endpoint `POST /api/auth/session` validates Stytch session token and finds/creates user
- Removed old `/api/auth/magic-link`, `/api/auth/authenticate`, `/api/auth/oauth` endpoints
- Removed `sendMagicLink`, `authenticateMagicLink`, `authenticateOAuth` from auth service
- Added `syncSession` to auth service (validates session + findOrCreateUser)
- Requires `VITE_STYTCH_PUBLIC_TOKEN` env var in `frontend/.env`
- Session auth middleware (`validateSession`) unchanged - still validates Stytch sessions for API calls

**Deferred items:**
- Editable memo field on secret detail
- Policy edit (update) UI - currently delete + recreate
- Audit log summary on secret detail (Phase 10)
- Gas usage summary on secret detail
- Secret preview on claim page (would need unauthenticated endpoint)

### Phase 10: Audit Logging System (COMPLETED)

**Completed: 2026-01-31**

**What was implemented:**
- Audit logging service (`src/audit/audit.service.ts`) with fire-and-forget `log()` function
- Query function with filtering (action type, status, date range) and pagination
- Single log detail retrieval, distinct action types query, and bulk export (up to 10k records)
- REST API endpoints at `/api/secrets/:secretId/audit-logs`:
  - `GET /` - List with filtering and pagination
  - `GET /actions` - Distinct action types for filter dropdown
  - `GET /export` - Export as JSON or CSV with Content-Disposition headers
  - `GET /:logId` - Single log detail
- All audit log endpoints require session auth + secret ownership
- Audit logging integrated into route handlers:
  - `skill.transfer` and `skill.send_transaction` in EVM wallet routes (with duration tracking)
  - `policy.create`, `policy.update`, `policy.delete` in policy routes
  - `apikey.create`, `apikey.revoke` in API key routes
  - `secret.claim`, `secret.delete` in secrets routes
- Frontend `AuditLogViewer` component with:
  - Filterable list by action type and status
  - Expandable entries showing full input/output JSON
  - CSV and JSON export buttons
  - Pagination controls
  - Status badges (green/red/yellow for SUCCESS/FAILED/PENDING)
- New "Audit Logs" tab added to SecretDetail page

**Key decisions made:**
- Audit logging is fire-and-forget: errors are caught and logged to console, never blocking the main request
- Logs capture IP address, user agent, duration (for skill executions), and both input/output data
- Export capped at 10,000 records as safety limit
- CSV export uses proper quoting with escaped double-quotes
- Skill execution audit logs map status: `executed` → SUCCESS, `denied` → FAILED, `pending_approval` → PENDING
- Distinct action types endpoint supports dynamic filter dropdowns in the UI

**Files created:**
- `src/audit/audit.service.ts` - Audit log service (log, query, getById, getActionTypes, exportLogs)
- `src/audit/index.ts` - Module exports
- `src/api/routes/auditLogs.routes.ts` - Audit log REST API endpoints
- `frontend/src/components/AuditLogViewer.tsx` - Audit log UI component

**Files modified:**
- `src/api/routes/index.ts` - Mounted audit log routes
- `src/api/routes/evmWallet.routes.ts` - Added audit logging to transfer and send-transaction
- `src/api/routes/policies.routes.ts` - Added audit logging to create, update, delete
- `src/api/routes/apiKeys.routes.ts` - Added audit logging to create and revoke
- `src/api/routes/secrets.routes.ts` - Added audit logging to claim and delete
- `frontend/src/api.ts` - Added audit log API functions
- `frontend/src/pages/SecretDetail.tsx` - Added Audit Logs tab

**Deferred items:**
- Telegram linking audit log (would require changes to bot callback handler)
- Log retention policy (configurable TTL/cleanup job)

**Next up: Phase 11 - Deployment & Operations**
- Railway setup
- CI/CD pipeline
- Monitoring and alerting

### Phase 13: Wallet Balances - Alchemy Portfolio API (COMPLETED)

**Completed: 2026-02-01**

**What was implemented:**
- Alchemy Portfolio API integration via direct HTTP calls (no SDK needed)
- `src/skills/alchemy.service.ts` - Portfolio service with multi-chain support (10 networks: Ethereum, Sepolia, Polygon, Arbitrum, Optimism, Base + testnets)
- Network chunking for Alchemy's 20-network-per-request limit
- `GET /api/skills/evm-wallet/balances` - API key authenticated endpoint for agents
- `GET /api/secrets/:id/balances` - Session authenticated endpoint for frontend
- Both endpoints support optional `chainIds` query param to filter networks
- `getPortfolioBalances()` in evmWallet.service.ts wraps Alchemy calls with wallet data lookup
- Frontend `BalancesDisplay` component with:
  - Grouped by network display
  - Token logos, symbols, names
  - Formatted balances with proper decimal handling
  - USD values when available
  - Zero-balance filtering
  - Manual refresh button
  - Error handling with retry
- Component integrated into SecretDetail page for EVM_WALLET secrets
- `ALCHEMY_API_KEY` added to env validation (optional)
- Frontend API client function `getSecretBalances()`

**Key decisions made:**
- Used Alchemy Portfolio API directly via fetch (no SDK dependency needed)
- Two endpoints: one for agents (API key auth), one for frontend (session auth + ownership)
- All supported networks queried by default when no chainIds filter provided
- Zero balances filtered out in frontend for cleaner display
- Balance formatting handles arbitrary decimals, truncated to 6 decimal places

**Files created:**
- `src/skills/alchemy.service.ts` - Alchemy Portfolio API client
- `frontend/src/components/BalancesDisplay.tsx` - Balance display component

**Files modified:**
- `src/utils/env.ts` - Added ALCHEMY_API_KEY
- `src/skills/evmWallet.service.ts` - Added getPortfolioBalances function
- `src/api/routes/evmWallet.routes.ts` - Added /balances endpoint (API key auth)
- `src/api/routes/secrets.routes.ts` - Added /:id/balances endpoint (session auth)
- `frontend/src/api.ts` - Added getSecretBalances function
- `frontend/src/pages/SecretDetail.tsx` - Integrated BalancesDisplay component

### Phase 14: Reverse Claim Flow (COMPLETED)

**Completed: 2026-02-01**

**What was implemented:**
- Re-link token generation endpoint (`POST /api/secrets/:id/relink-token`) with session auth + ownership
- Re-link token consumption endpoint (`POST /api/secrets/relink`) - unauthenticated, token is the auth
- One-time use tokens stored in-memory with 10-minute expiry
- Agent receives re-link token from user, exchanges it for a new API key + secret metadata
- Frontend "Generate Re-link Token" button on SecretDetail page with copy-to-clipboard
- Audit logging for both token generation (`secret.relink_token_generated`) and consumption (`secret.relinked`)

**Key decisions made:**
- Re-link tokens stored in-memory (same as Telegram linking codes) - sufficient for single-instance; would need Redis for multi-instance
- `/relink` POST route registered before `/:id` routes to prevent Express treating "relink" as a param
- Token is one-time use: consumed immediately on successful re-link, preventing replay
- No auth required on `/relink` endpoint since the token itself serves as authorization (similar to claim tokens)
- Optional `apiKeyName` parameter lets agent customize the API key name (defaults to "Re-linked API Key")

**Files modified:**
- `src/services/secret.service.ts` - Added `generateRelinkToken()` and `consumeRelinkToken()` functions
- `src/api/routes/secrets.routes.ts` - Added `/relink` and `/:id/relink-token` endpoints
- `frontend/src/api.ts` - Added `generateRelinkToken()` API function
- `frontend/src/pages/SecretDetail.tsx` - Added re-link token generation UI

**Next up: Phase 15 - 0x Token Swaps**
